["I mentioned that it is great to provide guarantees for production. However, as good agile software engineers\nwe want to release early and often, but translations are often an external dependency outside of the development team.\nTo combat this scenario, you may declare a fallback language in any translation file. Missing translations will then be pulled from\nthe referenced file (which may itself declare a fallback language).\nThe only limitation here is that the fallback graph needs to be acyclic.","Explicit fallbacks","In the Fluent format, any line beginning with \"#\" is considered a comment.\nA fallback language may be specified with a comment of the form {H0code|fallback-language: en|} \n(where \"en\" is the language to use as a fallback in this example).","Since JSON does not allow any comments, the fallback language needs to specified as a top-level, \nreserved key named {H0code|\"--fallback-language\"|}.","In the .properties format, any line beginning with \"#\" is considered a comment.\nA fallback language may be specified with a comment of the form {H0code|fallback-language: en|} \n(where \"en\" is the language to use as a fallback in this example).","Consistency","When working with other internalization solutions, translations are usually just simple key value maps.\nAnd when you have multiple of them, there is no check that they actually contain the same keys. \nThings are different here - since we analyse the translations at compile time already, we might as well check for completeness.\nThis is great to provide guarantees for production but is really annoying in development, most notably when you are using\nsome sort of watch mode that automatically runs Travelm-Agency on file changes.\nThe solution: The flag {H0code|--devMode|} disables the completeness check and result in an empty string if the translation\nis requested.     ","Missing keys","The time has come where we actually work with multiple input files.\nBut what are the consequences?"]